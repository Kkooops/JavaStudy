# 共享模型之无锁



## CAS 与 volatile

### CAS

多线程取钱可以使用有锁方式并发，也可以使用无锁的解决方法

```java
class AccountCas implements Account {
    private AtomicInteger balance;
    
    //...
    
    public Integer getBalance() {
        return balance.get();
    }
    
    public void withdraw(Integer amount) {
        while (true) {
            int prev = balance.get();
            int next = prev - amount;
          	if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

其中的关键是`compareAndSet`，它的简称是 CAS ，它必须是原子操作

### volatile 

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰

CAS 必须借助 volatile 才能读取到共享变量的最新值来实现**比较并交换**的效果



### 为什么无锁效率高？

+ 无所情况下，即时重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞
+ 但无锁情况下，因为线程要保持运行，需要额外的 CPU 的支持



### CAS 的特点

结合 CAS 和 volatile 可以实现无锁并发，适用于**线程数量少，多核CPU**的情况

+ CAS 是基于乐观锁的思想
+ synchronized 是基于悲观锁的思想
+ CAS 体现的是无所并发、无阻塞并发
  + 因为没有使用 synchronized，所以线程不会陷入阻塞
  + 如果竞争激烈，重试必然频繁发生，效率反而会受影响



## 原子引用

+ AtomicReference

  存在**ABA**问题，即无法感知中间过程中其他显示是否对值进行过修改，只会根据最终状态判断

  ```java
  @Slf4j
  public class Test2 {
      static AtomicReference<String> ref = new AtomicReference<>("A");
      public static void main(String[] args) throws InterruptedException {
          log.debug("main start");
  
          String prev = ref.get();
          other();
          Thread.sleep(1000);
          log.debug("change A -> C {}", ref.compareAndSet(prev, "C"));
      }
  
      public static void other() throws InterruptedException {
          new Thread(() -> {
              log.debug("change A -> B {}", ref.compareAndSet(ref.get(), "B"));
          }).start();
          Thread.sleep(300);
          new Thread(() -> {
              log.debug("change B -> A {}", ref.compareAndSet(ref.get(), "A"));
          }).start();
      }
  }
  
  // 输出：
  2024-09-25 21:02:02 [main] DEBUG- main start
  2024-09-25 21:02:02 [Thread-0] DEBUG- change A -> B true
  2024-09-25 21:02:02 [Thread-1] DEBUG- change B -> A true
  2024-09-25 21:02:03 [main] DEBUG- change A -> C true
  
  进程已结束，退出代码为 0
  ```

+ AtomicStampedReference

  可以使用 stamp (版本号) 避免 ABA 问题

  ```java
  @Slf4j
  public class Test2 {
      static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);
      public static void main(String[] args) throws InterruptedException {
          log.debug("main start");
  
          String prev = ref.getReference();
          int stamp = ref.getStamp();
          log.debug("stamp: {}", stamp);
          other();
          Thread.sleep(1000);
          log.debug("change A -> C {}", ref.compareAndSet(prev, "C", stamp, stamp + 1));
      }
  
      public static void other() throws InterruptedException {
          new Thread(() -> {
              int stamp = ref.getStamp();
              log.debug("change A -> B {}", ref.compareAndSet(ref.getReference(), "B", stamp, stamp + 1));
          }).start();
          Thread.sleep(300);
          new Thread(() -> {
              int stamp = ref.getStamp();
              log.debug("change B -> A {}", ref.compareAndSet(ref.getReference(), "A", stamp, stamp + 1));
          }).start();
      }
  }
  // 输出：
  2024-09-25 21:05:47 [main] DEBUG- main start
  2024-09-25 21:05:47 [main] DEBUG- stamp: 0
  2024-09-25 21:05:47 [Thread-0] DEBUG- change A -> B true
  2024-09-25 21:05:47 [Thread-1] DEBUG- change B -> A true
  2024-09-25 21:05:48 [main] DEBUG- change A -> C false
  
  进程已结束，退出代码为 0
  ```

+ AtomicMarkableReference

