# 并发工具

## 自定义线程池

![image-20240927095534232](https://s2.loli.net/2024/09/27/2uBOaC7XfyIt6AW.png)

```java
@Slf4j
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1,
                1000, TimeUnit.MILLISECONDS,
                1,
                (queue, task) -> {
            // 永久等待
//            queue.put(task);
            // 超时等待
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            // 放弃
//            log.debug("give up the task {}", task);
            // 让调用者抛出异常
//                throw new RuntimeException("task execute failed " + task);
            // 让调用者自己执行任务
                task.run();
        });
        for (int i = 0; i < 5; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                log.debug("{}", j);
            });
        }
    }

}

@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}

@Slf4j
class ThreadPool {
    private BlockingQueue<Runnable> taskQueue;

    private HashSet<Worker> workers = new HashSet<>();

    private int coreSize;

    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy<Runnable> rejectPolicy;

    public void execute(Runnable task) {
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("add worker: {} {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
//            while (task != null || (task = taskQueue.take()) != null) {
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("running... {}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug("worker removed: {}", this);
                workers.remove(this);
            }
        }
    }
}
@Slf4j
class BlockingQueue<T> {
    // 任务队列
    private Deque<T> queue = new ArrayDeque<>();

    // 锁
    private ReentrantLock lock = new ReentrantLock();

    // 生产者条件变量
    private Condition fullWaitSet = lock.newCondition();

    // 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();

    // 容量
    private int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    // 带超时的阻塞获取
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 返回的是剩余时间
                    if (nanos <= 0) return null;
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 带超时时间阻塞添加
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    if (nanos <= 0) return false;

                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否已满
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                log.debug("addLast taskQueue {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```



## ThreadPoolExecutor

### 线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

这些信息存储在一个原子变量 ctl 中，目的是将线程状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值

```java
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)));

private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                         int maximumPoolSize,
                         long keepAliveTime,
                         TimeUnit unit,
                         BlockingQueue<Runnable> workQueue,
                         ThreadFactory threadFactory,
                         RejectedExecutionHandler handler)
```

+ corePoolSize 核心线程数量（最多保留的线程数）
+ maximumPoolSize 最大线程数目
+ keepAliveTime 生存时间 - 针对救急线程
+ unit 时间单位 - 针对救急线程
+ workQueue 阻塞队列
+ threadFactory 线程工厂
+ handler 拒绝策略

线程池工作过程：

+ 一开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务
+ 当线程数量达到 corePoolSize 并且没有线程空闲，这时再加入任务，新加的任务会被加入 workQueue 队列排队，直到有空闲线程
+ 如果队列选择了有界队列，那么任务超过队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急
+ 如果线程达到 maximumPoolSize 仍然有新任务时这时会执行拒绝策略。拒绝策略 JDK 提供了4种，其他框架也提供了别的实现
  + AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
  + CallerRunPolicy 让调用者执行任务
  + DiscardPolicy 放弃本次任务
  + DiscardOldestPolicy放弃队列中最早的任务，本任务取而代之
  + Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
  + Netty 的实现，是创建一个新线程来执行任务
  + ActiveMQ 的实现，带超时等待（60s）尝试放入队列，
  + PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
+ 当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制

### newFixedThreadPool

特点：

+ 核心线程数 == 最大线程数
+ 阻塞队列是无界的，可以放置任意个数的任务

> 适用于任务数量固定，相对耗时的任务

### newCachedThreadPool

特点：

+ 核心线程数是0，最大线程数是 Integer.MAX_VALUE ，救急线程的空闲生存时间是 60s，意味着
  + 全部都是救急线程（60s后回收）
  + 救急线程可以无限创建
+ 队列采用了 SynchronousQueue 实现特点是：他没有容量，没有线程来取是放不进去的

> 适合任务数比较密集，但每个任务执行时间比较短的情况

### newSingleThreadExecutor

使用场景：

+ 希望多个任务排队执行。线程数固定为 1 ，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会释放

区别：

+ 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作
+ newSingleThreadExecutor的线程数始终为 1，不能修改，原理是通过装饰器模式对 ThreadPoolExecutor 进行包装，对外关闭了暴露的修改方法
+ 如果使用newFixedThreadPool(1) 创建，对外暴露的是 ThreadPoolExecutor 对象，可以强转之后修改线程池大小



### 提交任务

**execute 方法**

提交任务，没有返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);
pool.execute(() -> {
    log.info("执行任务");
});
```

**submit(Callable task) 方法 **

提交任务，并用 future 接收返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<String> future = pool.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                log.info("执行任务");
                return "返回结果";
            }
        });
        String res = future.get();
        log.info(res);
```

**invokeAll 方法**

提交集合中所有任务，可以带超时时间

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

List<Future<Integer>> futures = pool.invokeAll(Arrays.asList(
        () -> {
            log.info("执行任务1");
            Thread.sleep(100);
            return 1;
        },
        () -> {
            log.info("执行任务2");
            Thread.sleep(5000);
            return 2;
        }
));

futures.forEach( f -> {
    try {
        log.debug("返回值：{}", f.get());
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
});
```

**invokeAny 方法**

提交集合中所有任务，哪个任务先执行成功，返回此任务执行结果，其他任务取消

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

Integer res = pool.invokeAny(Arrays.asList(
        () -> {
            Thread.sleep(100);
            log.info("执行任务1");
            return 1;
        },
        () -> {
            Thread.sleep(300);
            log.info("执行任务2");
            return 2;
        }
));
log.debug("res: {}", res);
```

### 关闭线程池

shutdown方法

线程池状态变为**SHUTDOWN**，不会接收新任务，但已提交任务会执行完，此方法不会阻塞调用线程的执行



shutdownNow方法

线程池状态变为**STOP**，不会接收新任务，会将队列中的任务返回，并用 interrupt 的方式中断正在执行的任务



### 工作线程的饥饿现象

如果一个线程既要负责A的执行又要负责B的执行，并且A与B之前存在关系，那么可能导致**饥饿**现象

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }
}

// 输出：
2024-09-27 15:41:37 [pool-1-thread-2] INFO - 点餐
2024-09-27 15:41:37 [pool-1-thread-1] INFO - 点餐
```

**解决方式**

创建不同的线程池分别负责不同类型的任务，可以避免**饥饿现象**

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        ExecutorService pool2 = Executors.newFixedThreadPool(1);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        Thread.sleep(1000);
        pool.shutdown();
        pool2.shutdown();
    }
}

// 输出：
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜

进程已结束，退出代码为 0
```



### 创建多少线程池合适？

对于**CPU密集型**运算

> 通常采用**CPU 核数 + 1**能够实现最优的 CPU 利用率，**+1**是保证当线程由于页缺失故障或其他原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不浪费

对于 **I/O 密集型**运算

> 经验公式：`线程数 = 核数 * 期望 CPU 利用率 * 总时间（CPU计算时间 + 等待时间）/ CPU 计算时间`



## 任务调度线程池

**schedule方法**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
    pool.schedule(() -> {
        log.info("task1");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
    pool.schedule(() -> {
        log.info("task2");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
}
```

**scheduleWithFixedDelay方法**

**scheduleAtFixedRate方法**



## 线程池的异常处理

1. 直接在任务内部捕捉异常
2. 使用`Callable<T>`来执行任务并带有返回值，调用`Future.get()`会捕捉异常



## 任务调度线程池应用 - 定时任务

```java
public class TestSubmit {

    // 如何让每周四 18：00：00定时执行任务
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);

        if (now.isAfter(time)) time.plusWeeks(1);
        System.out.println(time);


        long initDelay = Duration.between(now, time).toMillis();
        System.out.println(initDelay);
        long period = 2000;

        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
        pool.scheduleAtFixedRate(() -> {
            log.info("yes");
        }, initDelay, period, TimeUnit.MILLISECONDS);
    }
}
```



## Tomcat 线程池

Tomcat 在哪里用到了线程池呢？

![image-20240927164100537](https://s2.loli.net/2024/09/27/69ZtIc7GfRnHe18.png)

+ LimitLatch 用来限流，可以控制最大连接数
+ Acceptor 只负责**接收新的 socket 连接**
+ Poller 只负责监听 socket channel 是否有**可读的 I/O 事件**
+ 一旦可读，封装到一个任务对象**socketProcessor**，提交给 Executor 线程池处理
+ Executor 线程池中的工作线程最终负责**处理请求**

Tomcat线程池**拓展了**ThreadPoolExecutor，行为稍有不同

+ 如果总线程达到 maximumPoolSize
  + 这时不会立刻抛异常
  + 而是再次尝试将任务放入队列，如果还失败才抛异常

Tomcat 对于救急线程的创建流程也进行了改变

![image-20240927165548316](https://s2.loli.net/2024/09/27/RvcxND6tlHYEgq8.png)



## Fork/Join

JDK 1.7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算

Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提高了运算效率

默认会创建与 CPU 核心数相同的线程池

```java
public class TestForkJoin {
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool(10);
        for (int i = 0; i < 10; i++) {
            long start = System.currentTimeMillis();
            System.out.println(pool.invoke(new MyTask(1, 1000000000)));
            long end = System.currentTimeMillis();
            System.out.println(end - start);
        }
    }
}

@Slf4j
class MyTask extends RecursiveTask<Integer> {

    private int begin;
    private int end;

    public MyTask(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (begin == end) {
            return begin;
        }
        if (end == begin + 1) {
            return begin + end;
        }

        int mid = (begin + end) >> 1;
        MyTask t1 = new MyTask(begin, mid);
        MyTask t2 = new MyTask(mid + 1, end);
        t1.fork();
        t2.fork();
//        log.debug("fork() {} + {} = ?", t1, t2);
        int result = t1.join() + t2.join();
//        log.debug("join() {} + {} = {}", t1, t2, result);
        return result;
    }
}
```

## J.U.C

### AQS 原理

全称 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架

特点：

+ 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
  + getState 获取 state 状态
  + setState 设置 state 状态
  + compareAndSetState 使用 cas 机制设置 state 状态
  + 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
+ 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
+ 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

### 使用AQS实现一个自定义锁

```java
// 自定义锁 （不可重入锁）
class MyLock implements Lock {

    // 独占锁 同步器类
    class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }

    private MySync sync = new MySync();

    @Override // 加锁 不成功进入等待队列
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override // 尝试加锁 一次
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override // 尝试加锁 带超时
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override // 创建条件变量
    public Condition newCondition() {
        return sync.newCondition();
    }
}
```



### ReentrantLock 原理

![image-20240929162319146](https://s2.loli.net/2024/09/29/Il1mYysS4DbJRar.png)

默认为非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

NonfairSync 继承自 AQS



#### 非公平锁实现原理

**加锁代码如下**

```java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
```

没有竞争时

![image-20240929162641467](https://s2.loli.net/2024/09/29/CubyPYRV4NpgHkM.png)

第一个竞争出现时

![image-20240929162923261](https://s2.loli.net/2024/09/29/OFE9X6gCDGMSV1j.png)

CAS 尝试失败，进入 tryAcquire 逻辑，仍然失败，进入 addWaiter 逻辑，构造 Node 队列

+ 图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态
+ Node 的创建时懒惰的
+ 其中第一个 Node 称之为 Dummy 或哨兵，用来占位，并不关联线程

![image-20240929163210549](https://s2.loli.net/2024/09/29/i3q6Twk1PupSn4d.png) 

当前阶段进入 acquireQueued 逻辑

```java
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞
2. 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获得锁，当然这时 state 仍为 1 ，失败
3. 进入 shouldParkAferFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false

![image-20240929164156494](https://s2.loli.net/2024/09/29/8KRH5yOp2AV7UN9.png)

4. shouldParkAfterFailedAcquire 执行完毕后回到 acquireQueued，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1 ，失败

5. 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true

6. 进入 parkAndCheckInterrupt ，Thread - 1 **park**

   ```java
   private final boolean parkAndCheckInterrupt() {
       LockSupport.park(this);
       return Thread.interrupted();
   } 
   ```

   ![image-20240929164643072](https://s2.loli.net/2024/09/29/BuQICf4sxnErX7w.png)

**假设**再有多个线程经历上述过程竞争失败，结果如下图

![image-20240929164831171](https://s2.loli.net/2024/09/29/WaDlspcyKNrBMvZ.png)

Thread-0 释放锁，进入 tryRelease 流程，如果成功

```java
protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```

+ 设置 exclusiveOwnerThread 为 null
+ state = 0

![image-20240929164831171](https://s2.loli.net/2024/09/29/WaDlspcyKNrBMvZ.png)

当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程

找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1

回到 Thread-1 的 acquireQueued 流程

如果加锁成功，会设置

+ exclusiveOwnerThread 为 Thread-1，state = 1
+ head 指向刚刚 Thread-1 所在的 Node, 该 Node 清空 Thread
+ 原本的 head 因为从链表断开，可被垃圾回收

![image-20240929175641909](https://s2.loli.net/2024/09/29/wjhOdLGxTKecRgJ.png)

如果这个时候有其他线程来竞争（**非公平的体现**），例如这时有 Thread-4 来了（不在等待队列）

![image-20240929180123374](https://s2.loli.net/2024/09/29/w3LVp2radc6buHU.png)

不巧又被 Thread-4 抢占去了

+ Thread-4 被设置为 exclusiveOwnerThread，state = 1
+ Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞

#### 可重入原理

```java
static final class NonfairSync extends Sync {
    // ...
    
    // 继承过来的方法
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) { 
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入 state == 0 才释放锁
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
```

`current == getExclusiveOwnerThread()`锁重入时判断条件，会让`state`加一

释放锁时如果有重入的锁，只有在 state == 0 时才会返回 true，表示当前线程释放锁成功



#### 可打断原理

##### 不可打断模式

在此模式下，即使它被打断，仍会驻留在 AQS 队列中，等获得锁后方能继续运行

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                // 如果有打断 置为 true
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
        selfInterrupt(); // 获得锁之后才能运行打断代码
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```



##### 可打断模式

在 park 过程中如果被打断会抛出异常，也就不用继续等待锁了

```java
// NonFairSync 继承过来的方法
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```



#### 公平锁实现原理

在新线程去开始抢占锁之前会检查 AQS 队列中是否还有前驱节点（也就是等待的线程）

关键代码`!hasQueuedPredecessors()`

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }

    /**
     * Fair version of tryAcquire.  Don't grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) 
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
```



### 条件变量实现原理

每个条件变量其实就对应着一个等待队列，其实现类是 **ConditionObject**

**await 流程**

开始 Thread-0 持有锁，调用 await ，进入 ConditionObject 的 addConditionWaiter 流程

创建新的 Node 状态为 -2 （Node.CONDITION），关联 Thread-0，加入等待队列尾部

```java
private Node addConditionWaiter() {
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    if (t != null && t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
```

![image-20240929183330302](https://s2.loli.net/2024/09/29/V1h5NPSOFHkBU8f.png)

接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁

```java
final int fullyRelease(Node node) {
    boolean failed = true;
    try {
        int savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
```

![image-20240929183736698](https://s2.loli.net/2024/09/29/uZ6RUNWwOh5aVdr.png)

unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功

**signal流程**

假设 Thread-1 要来唤醒 Thread-0

```java
public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}
```

![image-20240929184201807](https://s2.loli.net/2024/09/29/mWzhUPsQxZqdBfr.png)

进入 doSignal 流程，取得等待队列中的第一个 Node，即 Thread-0 所在的 Node

```java
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null);
}
```

![image-20240929184456367](https://s2.loli.net/2024/09/29/3ZaqAroFd9VkIXW.png)

执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1

```java
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
```

![image-20240929185409580](https://s2.loli.net/2024/09/29/eNxA4zT9Fr7WYlp.png)

Thread-1 释放锁，进入unlock流程，完毕



### 读写锁

#### ReentrantReadWriteLock

当读操作远远高于写操作时，这时候使用**读写锁**让**读-读**可以并发，提高性能

提供一个**数据容器类**，内部分别使用读锁保护数据的`read()`方法，写锁保护数据的`write()`方法

```java
public class TestReadWriteLock {

    public static void main(String[] args) throws InterruptedException {
        DataContainer dataContainer = new DataContainer();
        new Thread(() -> {
            dataContainer.read();
        }, "t1").start();
        Thread.sleep(5);
        new Thread(() -> {
            dataContainer.read();
        }, "t2").start();
        Thread.sleep(100);
        new Thread(() -> {
            dataContainer.write();
        }, "t3").start();
    }
}

@Slf4j
class DataContainer {
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();

    public Object read() {
        log.debug("获取读锁");
        r.lock();
        try {
            log.debug("读取");
            Thread.sleep(2000);
            return data;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            log.debug("释放读锁");
            r.unlock();
        }
    }

    public void write() {
        log.debug("获取写锁");
        w.lock();
        try {
            log.debug("写入");
        } finally {
            log.debug("释放写锁");
            w.unlock();
        }
    }
}
```

**注意事项**

+ 读锁不支持条件变量

+ 重入时升级不支持：**即持有读锁的情况下去获取写锁，会导致获取写锁永久等待**

+ 重入时降级支持：即持有写锁的情况下去获取读锁

  ```java
  class CachedData {
      Object data;
      volatile boolean cacheValid;
      final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
      final ReentrantReadWriteLock.ReadLock r = rwl.readLock();
      final ReentrantReadWriteLock.WriteLock w = rwl.writeLock();
      
      void processCachedData() {
          r.lock();
          if (!cacheValid) {
              r.unlock();
              w.lock();
              try {
                  if (!cacheValid) {
                      data = ...;
                      cacheValid = true;
                  }
                  r.lock();
              } finally {
                  w.unlock();
              }
          }
          
          try {
              use(data);
          } finally {
              r.unlock();
          }
      }
  }
  ```

### 读写锁原理

读写锁用的是同一个 Sync 同步器，因此等待队列、state 等也是同一个

**t1  -->  w.lock   t2  -->  r.lock**

1. t1 成功上锁，流程与 ReentrantLock 加锁相比没有特别之处，不同的是写锁状态占了 state 的低16位，而读锁使用的是 state 的高16位

   ![image-20240929195621270](https://s2.loli.net/2024/09/29/y75iV9MSd8xYh6U.png)

   ```java
   protected final boolean tryAcquire(int acquires) {
       /*
        * Walkthrough:
        * 1. If read count nonzero or write count nonzero
        *    and owner is a different thread, fail.
        * 2. If count would saturate, fail. (This can only
        *    happen if count is already nonzero.)
        * 3. Otherwise, this thread is eligible for lock if
        *    it is either a reentrant acquire or
        *    queue policy allows it. If so, update state
        *    and set owner.
        */
       Thread current = Thread.currentThread();
       int c = getState();
       int w = exclusiveCount(c);
       if (c != 0) {
           // (Note: if c != 0 and w == 0 then shared count != 0)
           if (w == 0 || current != getExclusiveOwnerThread())
               return false;
           if (w + exclusiveCount(acquires) > MAX_COUNT)
               throw new Error("Maximum lock count exceeded");
           // Reentrant acquire
           setState(c + acquires);
           return true;
       }
       if (writerShouldBlock() ||
           !compareAndSetState(c, c + acquires))
           return false;
       setExclusiveOwnerThread(current);
       return true;
   }
   ```

2. t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么返回 -1 表示失败

   ```java
    public final void acquireShared(int arg) {
       if (tryAcquireShared(arg) < 0)
           doAcquireShared(arg);
   }
   ```

   > tryAcquireShared 返回值含义：
   >
   > + **-1** 表示失败
   > + **0** 表示成功，但后继节点不会继续唤醒
   > + **正数**表示成功，而且数值是还有几个后继节点需要唤醒，**读写锁返回 1**

   ![image-20240929195925732](https://s2.loli.net/2024/09/29/eWkJmUQ7uGhd3ia.png)

   ```java
   protected final int tryAcquireShared(int unused) {
       /*
        * Walkthrough:
        * 1. If write lock held by another thread, fail.
        * 2. Otherwise, this thread is eligible for
        *    lock wrt state, so ask if it should block
        *    because of queue policy. If not, try
        *    to grant by CASing state and updating count.
        *    Note that step does not check for reentrant
        *    acquires, which is postponed to full version
        *    to avoid having to check hold count in
        *    the more typical non-reentrant case.
        * 3. If step 2 fails either because thread
        *    apparently not eligible or CAS fails or count
        *    saturated, chain to version with full retry loop.
        */
       Thread current = Thread.currentThread();
       int c = getState();
       if (exclusiveCount(c) != 0 &&
           getExclusiveOwnerThread() != current)
           return -1;
       int r = sharedCount(c);
       if (!readerShouldBlock() &&
           r < MAX_COUNT &&
           compareAndSetState(c, c + SHARED_UNIT)) {
           if (r == 0) {
               firstReader = current;
               firstReaderHoldCount = 1;
           } else if (firstReader == current) {
               firstReaderHoldCount++;
           } else {
               HoldCounter rh = cachedHoldCounter;
               if (rh == null || rh.tid != getThreadId(current))
                   cachedHoldCounter = rh = readHolds.get();
               else if (rh.count == 0)
                   readHolds.set(rh);
               rh.count++;
           }
           return 1;
       }
       return fullTryAcquireShared(current);
   }
   ```

3. 上面一步因为写锁占据，所以进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态

   ```java
   private void doAcquireShared(int arg) {
       final Node node = addWaiter(Node.SHARED);
       boolean failed = true;
       try {
           boolean interrupted = false;
           for (;;) {
               final Node p = node.predecessor();
               if (p == head) {
                   int r = tryAcquireShared(arg);
                   if (r >= 0) {
                       setHeadAndPropagate(node, r);
                       p.next = null; // help GC
                       if (interrupted)
                           selfInterrupt();
                       failed = false;
                       return;
                   }
               }
               if (shouldParkAfterFailedAcquire(p, node) &&
                   parkAndCheckInterrupt())
                   interrupted = true;
           }
       } finally {
           if (failed)
               cancelAcquire(node);
       }
   }
   ```

   ![image-20240929200832623](https://s2.loli.net/2024/09/29/c8ZxL9J5G3thdYe.png)

4. t2 会再看看自己的节点是不是第一个关联线程的节点，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁

5. 如果没有成功，在 doAcquireShared 内 for 循环一次，把前驱节点的 waitStatus 改为 -1，再 for 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 **park**

   ![image-20240929201304593](https://s2.loli.net/2024/09/29/nJMaZNbGYRCcq8k.png)

**t3 r.lock, t4 w.lock**

这种情况下，这期间 t1 仍然持有锁，就变成下图：

**注意：**写锁的状态是 EXCULSIVE 独占状态（图中 Ex)

![image-20240929201432513](https://s2.loli.net/2024/09/29/JXCQyal4I2rnTfH.png)

**t1 w.unlock**

这时会走 sync.release(1) 流程，调用 sync.release(1) 成功

![image-20240929201640548](https://s2.loli.net/2024/09/29/HzXsilYOKomcShL.png)

接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行

这时再来一次 for 循环执行 tryAcquireShared 成功则让读锁计数加一

![image-20240929202259693](https://s2.loli.net/2024/09/29/5tHG2g4wcyolZPW.png)

这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点

![image-20240929202429591](https://s2.loli.net/2024/09/29/S3xFr15ObwREVKs.png)

在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并且唤醒这下一个节点，此时 t3 也恢复运行

![image-20240929202725781](https://s2.loli.net/2024/09/29/FDuLjlPhXqs7atW.png)

这回再来一次执行 tryAcquireShared 成功则让读锁计数加一

![image-20240929202957103](https://s2.loli.net/2024/09/29/OMfNY1hkR2EmowU.png)

这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在的节点置为头节点

![image-20240929203142223](https://s2.loli.net/2024/09/29/a2cvw51WsyYhGnI.png)

**t2 r.unlock  t3 r.unlock**

t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为 0

![image-20240929203417897](https://s2.loli.net/2024/09/29/LGs4PNzaDhgr8iY.png)

t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为0，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点也就是 t4

<img src="https://s2.loli.net/2024/09/29/snB4W8eO79JVFmd.png" alt="image-20240929203805260"  />

之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for 循环，这次没有竞争，tryAcquire(1) 成功，修改头节点，结束流程
