# 并发工具

## 自定义线程池

![image-20240927095534232](https://s2.loli.net/2024/09/27/2uBOaC7XfyIt6AW.png)

```java
@Slf4j
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1,
                1000, TimeUnit.MILLISECONDS,
                1,
                (queue, task) -> {
            // 永久等待
//            queue.put(task);
            // 超时等待
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            // 放弃
//            log.debug("give up the task {}", task);
            // 让调用者抛出异常
//                throw new RuntimeException("task execute failed " + task);
            // 让调用者自己执行任务
                task.run();
        });
        for (int i = 0; i < 5; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                log.debug("{}", j);
            });
        }
    }

}

@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}

@Slf4j
class ThreadPool {
    private BlockingQueue<Runnable> taskQueue;

    private HashSet<Worker> workers = new HashSet<>();

    private int coreSize;

    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy<Runnable> rejectPolicy;

    public void execute(Runnable task) {
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("add worker: {} {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
//            while (task != null || (task = taskQueue.take()) != null) {
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("running... {}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug("worker removed: {}", this);
                workers.remove(this);
            }
        }
    }
}
@Slf4j
class BlockingQueue<T> {
    // 任务队列
    private Deque<T> queue = new ArrayDeque<>();

    // 锁
    private ReentrantLock lock = new ReentrantLock();

    // 生产者条件变量
    private Condition fullWaitSet = lock.newCondition();

    // 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();

    // 容量
    private int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    // 带超时的阻塞获取
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 返回的是剩余时间
                    if (nanos <= 0) return null;
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 带超时时间阻塞添加
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    if (nanos <= 0) return false;

                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否已满
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                log.debug("addLast taskQueue {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```



## ThreadPoolExecutor

### 线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

这些信息存储在一个原子变量 ctl 中，目的是将线程状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值

```java
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)));

private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                         int maximumPoolSize,
                         long keepAliveTime,
                         TimeUnit unit,
                         BlockingQueue<Runnable> workQueue,
                         ThreadFactory threadFactory,
                         RejectedExecutionHandler handler)
```

+ corePoolSize 核心线程数量（最多保留的线程数）
+ maximumPoolSize 最大线程数目
+ keepAliveTime 生存时间 - 针对救急线程
+ unit 时间单位 - 针对救急线程
+ workQueue 阻塞队列
+ threadFactory 线程工厂
+ handler 拒绝策略

线程池工作过程：

+ 一开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务
+ 当线程数量达到 corePoolSize 并且没有线程空闲，这时再加入任务，新加的任务会被加入 workQueue 队列排队，直到有空闲线程
+ 如果队列选择了有界队列，那么任务超过队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急
+ 如果线程达到 maximumPoolSize 仍然有新任务时这时会执行拒绝策略。拒绝策略 JDK 提供了4种，其他框架也提供了别的实现
  + AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
  + CallerRunPolicy 让调用者执行任务
  + DiscardPolicy 放弃本次任务
  + DiscardOldestPolicy放弃队列中最早的任务，本任务取而代之
  + Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
  + Netty 的实现，是创建一个新线程来执行任务
  + ActiveMQ 的实现，带超时等待（60s）尝试放入队列，
  + PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
+ 当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制

### newFixedThreadPool

特点：

+ 核心线程数 == 最大线程数
+ 阻塞队列是无界的，可以放置任意个数的任务

> 适用于任务数量固定，相对耗时的任务

### newCachedThreadPool

特点：

+ 核心线程数是0，最大线程数是 Integer.MAX_VALUE ，救急线程的空闲生存时间是 60s，意味着
  + 全部都是救急线程（60s后回收）
  + 救急线程可以无限创建
+ 队列采用了 SynchronousQueue 实现特点是：他没有容量，没有线程来取是放不进去的

> 适合任务数比较密集，但每个任务执行时间比较短的情况

### newSingleThreadExecutor

使用场景：

+ 希望多个任务排队执行。线程数固定为 1 ，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会释放

区别：

+ 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作
+ newSingleThreadExecutor的线程数始终为 1，不能修改，原理是通过装饰器模式对 ThreadPoolExecutor 进行包装，对外关闭了暴露的修改方法
+ 如果使用newFixedThreadPool(1) 创建，对外暴露的是 ThreadPoolExecutor 对象，可以强转之后修改线程池大小



### 提交任务

**execute 方法**

提交任务，没有返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);
pool.execute(() -> {
    log.info("执行任务");
});
```

**submit(Callable task) 方法 **

提交任务，并用 future 接收返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<String> future = pool.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                log.info("执行任务");
                return "返回结果";
            }
        });
        String res = future.get();
        log.info(res);
```

**invokeAll 方法**

提交集合中所有任务，可以带超时时间

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

List<Future<Integer>> futures = pool.invokeAll(Arrays.asList(
        () -> {
            log.info("执行任务1");
            Thread.sleep(100);
            return 1;
        },
        () -> {
            log.info("执行任务2");
            Thread.sleep(5000);
            return 2;
        }
));

futures.forEach( f -> {
    try {
        log.debug("返回值：{}", f.get());
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
});
```

**invokeAny 方法**

提交集合中所有任务，哪个任务先执行成功，返回此任务执行结果，其他任务取消

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

Integer res = pool.invokeAny(Arrays.asList(
        () -> {
            Thread.sleep(100);
            log.info("执行任务1");
            return 1;
        },
        () -> {
            Thread.sleep(300);
            log.info("执行任务2");
            return 2;
        }
));
log.debug("res: {}", res);
```

### 关闭线程池

shutdown方法

线程池状态变为**SHUTDOWN**，不会接收新任务，但已提交任务会执行完，此方法不会阻塞调用线程的执行



shutdownNow方法

线程池状态变为**STOP**，不会接收新任务，会将队列中的任务返回，并用 interrupt 的方式中断正在执行的任务



### 工作线程的饥饿现象

如果一个线程既要负责A的执行又要负责B的执行，并且A与B之前存在关系，那么可能导致**饥饿**现象

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }
}

// 输出：
2024-09-27 15:41:37 [pool-1-thread-2] INFO - 点餐
2024-09-27 15:41:37 [pool-1-thread-1] INFO - 点餐
```

**解决方式**

创建不同的线程池分别负责不同类型的任务，可以避免**饥饿现象**

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        ExecutorService pool2 = Executors.newFixedThreadPool(1);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        Thread.sleep(1000);
        pool.shutdown();
        pool2.shutdown();
    }
}

// 输出：
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜

进程已结束，退出代码为 0
```



### 创建多少线程池合适？

对于**CPU密集型**运算

> 通常采用**CPU 核数 + 1**能够实现最优的 CPU 利用率，**+1**是保证当线程由于页缺失故障或其他原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不浪费

对于 **I/O 密集型**运算

> 经验公式：`线程数 = 核数 * 期望 CPU 利用率 * 总时间（CPU计算时间 + 等待时间）/ CPU 计算时间`



## 任务调度线程池

**schedule方法**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
    pool.schedule(() -> {
        log.info("task1");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
    pool.schedule(() -> {
        log.info("task2");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
}
```

**scheduleWithFixedDelay方法**

**scheduleAtFixedRate方法**



## 线程池的异常处理

1. 直接在任务内部捕捉异常
2. 使用`Callable<T>`来执行任务并带有返回值，调用`Future.get()`会捕捉异常



## 任务调度线程池应用 - 定时任务

```java
public class TestSubmit {

    // 如何让每周四 18：00：00定时执行任务
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);

        if (now.isAfter(time)) time.plusWeeks(1);
        System.out.println(time);


        long initDelay = Duration.between(now, time).toMillis();
        System.out.println(initDelay);
        long period = 2000;

        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
        pool.scheduleAtFixedRate(() -> {
            log.info("yes");
        }, initDelay, period, TimeUnit.MILLISECONDS);
    }
}
```



## Tomcat 线程池

Tomcat 在哪里用到了线程池呢？

![image-20240927164100537](https://s2.loli.net/2024/09/27/69ZtIc7GfRnHe18.png)

+ LimitLatch 用来限流，可以控制最大连接数
+ Acceptor 只负责**接收新的 socket 连接**
+ Poller 只负责监听 socket channel 是否有**可读的 I/O 事件**
+ 一旦可读，封装到一个任务对象**socketProcessor**，提交给 Executor 线程池处理
+ Executor 线程池中的工作线程最终负责**处理请求**

Tomcat线程池**拓展了**ThreadPoolExecutor，行为稍有不同

+ 如果总线程达到 maximumPoolSize
  + 这时不会立刻抛异常
  + 而是再次尝试将任务放入队列，如果还失败才抛异常

Tomcat 对于救急线程的创建流程也进行了改变

![image-20240927165548316](https://s2.loli.net/2024/09/27/RvcxND6tlHYEgq8.png)



## Fork/Join

JDK 1.7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算

Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提高了运算效率

默认会创建与 CPU 核心数相同的线程池

```java
public class TestForkJoin {
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool(10);
        for (int i = 0; i < 10; i++) {
            long start = System.currentTimeMillis();
            System.out.println(pool.invoke(new MyTask(1, 1000000000)));
            long end = System.currentTimeMillis();
            System.out.println(end - start);
        }
    }
}

@Slf4j
class MyTask extends RecursiveTask<Integer> {

    private int begin;
    private int end;

    public MyTask(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (begin == end) {
            return begin;
        }
        if (end == begin + 1) {
            return begin + end;
        }

        int mid = (begin + end) >> 1;
        MyTask t1 = new MyTask(begin, mid);
        MyTask t2 = new MyTask(mid + 1, end);
        t1.fork();
        t2.fork();
//        log.debug("fork() {} + {} = ?", t1, t2);
        int result = t1.join() + t2.join();
//        log.debug("join() {} + {} = {}", t1, t2, result);
        return result;
    }
}
```

## J.U.C

### AQS 原理

全称 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架

特点：

+ 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
  + getState 获取 state 状态
  + setState 设置 state 状态
  + compareAndSetState 使用 cas 机制设置 state 状态
  + 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
+ 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
+ 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

### 使用AQS实现一个自定义锁

```java
// 自定义锁 （不可重入锁）
class MyLock implements Lock {

    // 独占锁 同步器类
    class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }

    private MySync sync = new MySync();

    @Override // 加锁 不成功进入等待队列
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override // 尝试加锁 一次
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override // 尝试加锁 带超时
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override // 创建条件变量
    public Condition newCondition() {
        return sync.newCondition();
    }
}
```



### ReentrantLock 原理

![image-20240929162319146](https://s2.loli.net/2024/09/29/Il1mYysS4DbJRar.png)

默认为非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

NonfairSync 继承自 AQS



#### 非公平锁实现原理

**加锁代码如下**

```java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
```

没有竞争时

![image-20240929162641467](https://s2.loli.net/2024/09/29/CubyPYRV4NpgHkM.png)

第一个竞争出现时

![image-20240929162923261](https://s2.loli.net/2024/09/29/OFE9X6gCDGMSV1j.png)

CAS 尝试失败，进入 tryAcquire 逻辑，仍然失败，进入 addWaiter 逻辑，构造 Node 队列

+ 图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态
+ Node 的创建时懒惰的
+ 其中第一个 Node 称之为 Dummy 或哨兵，用来占位，并不关联线程

![image-20240929163210549](https://s2.loli.net/2024/09/29/i3q6Twk1PupSn4d.png) 

当前阶段进入 acquireQueued 逻辑

```java
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞
2. 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获得锁，当然这时 state 仍为 1 ，失败
3. 进入 shouldParkAferFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false

![image-20240929164156494](https://s2.loli.net/2024/09/29/8KRH5yOp2AV7UN9.png)

4. shouldParkAfterFailedAcquire 执行完毕后回到 acquireQueued，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1 ，失败

5. 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true

6. 进入 parkAndCheckInterrupt ，Thread - 1 **park**

   ```java
   private final boolean parkAndCheckInterrupt() {
       LockSupport.park(this);
       return Thread.interrupted();
   } 
   ```

   ![image-20240929164643072](https://s2.loli.net/2024/09/29/BuQICf4sxnErX7w.png)

**假设**再有多个线程经历上述过程竞争失败，结果如下图

![image-20240929164831171](https://s2.loli.net/2024/09/29/WaDlspcyKNrBMvZ.png)

Thread-0 释放锁，进入 tryRelease 流程，如果成功

```java
protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```

+ 设置 exclusiveOwnerThread 为 null
+ state = 0

![image-20240929164831171](https://s2.loli.net/2024/09/29/WaDlspcyKNrBMvZ.png)

当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程

找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1

回到 Thread-1 的 acquireQueued 流程

如果加锁成功，会设置

+ exclusiveOwnerThread 为 Thread-1，state = 1
+ head 指向刚刚 Thread-1 所在的 Node, 该 Node 清空 Thread
+ 原本的 head 因为从链表断开，可被垃圾回收

![image-20240929175641909](https://s2.loli.net/2024/09/29/wjhOdLGxTKecRgJ.png)

如果这个时候有其他线程来竞争（**非公平的体现**），例如这时有 Thread-4 来了（不在等待队列）

![image-20240929180123374](https://s2.loli.net/2024/09/29/w3LVp2radc6buHU.png)

不巧又被 Thread-4 抢占去了

+ Thread-4 被设置为 exclusiveOwnerThread，state = 1
+ Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞

#### 可重入原理

```java
static final class NonfairSync extends Sync {
    // ...
    
    // 继承过来的方法
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) { 
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入 state == 0 才释放锁
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
```

`current == getExclusiveOwnerThread()`锁重入时判断条件，会让`state`加一

释放锁时如果有重入的锁，只有在 state == 0 时才会返回 true，表示当前线程释放锁成功



#### 可打断原理

##### 不可打断模式

在此模式下，即使它被打断，仍会驻留在 AQS 队列中，等获得锁后方能继续运行

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                // 如果有打断 置为 true
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
        selfInterrupt(); // 获得锁之后才能运行打断代码
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```



##### 可打断模式

在 park 过程中如果被打断会抛出异常，也就不用继续等待锁了

```java
// NonFairSync 继承过来的方法
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```



#### 公平锁实现原理

在新线程去开始抢占锁之前会检查 AQS 队列中是否还有前驱节点（也就是等待的线程）

关键代码`!hasQueuedPredecessors()`

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }

    /**
     * Fair version of tryAcquire.  Don't grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) 
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
```



### 条件变量实现原理

每个条件变量其实就对应着一个等待队列，其实现类是 **ConditionObject**

**await 流程**

开始 Thread-0 持有锁，调用 await ，进入 ConditionObject 的 addConditionWaiter 流程

创建新的 Node 状态为 -2 （Node.CONDITION），关联 Thread-0，加入等待队列尾部

```java
private Node addConditionWaiter() {
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    if (t != null && t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
```

![image-20240929183330302](https://s2.loli.net/2024/09/29/V1h5NPSOFHkBU8f.png)

接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁

```java
final int fullyRelease(Node node) {
    boolean failed = true;
    try {
        int savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
```

![image-20240929183736698](https://s2.loli.net/2024/09/29/uZ6RUNWwOh5aVdr.png)

unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功

**signal流程**

假设 Thread-1 要来唤醒 Thread-0

```java
public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}
```

![image-20240929184201807](https://s2.loli.net/2024/09/29/mWzhUPsQxZqdBfr.png)

进入 doSignal 流程，取得等待队列中的第一个 Node，即 Thread-0 所在的 Node

```java
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null);
}
```

![image-20240929184456367](https://s2.loli.net/2024/09/29/3ZaqAroFd9VkIXW.png)

执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1

```java
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
```

![image-20240929185409580](https://s2.loli.net/2024/09/29/eNxA4zT9Fr7WYlp.png)

Thread-1 释放锁，进入unlock流程，完毕



### 读写锁

#### ReentrantReadWriteLock

当读操作远远高于写操作时，这时候使用**读写锁**让**读-读**可以并发，提高性能

提供一个**数据容器类**，内部分别使用读锁保护数据的`read()`方法，写锁保护数据的`write()`方法

```java
public class TestReadWriteLock {

    public static void main(String[] args) throws InterruptedException {
        DataContainer dataContainer = new DataContainer();
        new Thread(() -> {
            dataContainer.read();
        }, "t1").start();
        Thread.sleep(5);
        new Thread(() -> {
            dataContainer.read();
        }, "t2").start();
        Thread.sleep(100);
        new Thread(() -> {
            dataContainer.write();
        }, "t3").start();
    }
}

@Slf4j
class DataContainer {
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();

    public Object read() {
        log.debug("获取读锁");
        r.lock();
        try {
            log.debug("读取");
            Thread.sleep(2000);
            return data;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            log.debug("释放读锁");
            r.unlock();
        }
    }

    public void write() {
        log.debug("获取写锁");
        w.lock();
        try {
            log.debug("写入");
        } finally {
            log.debug("释放写锁");
            w.unlock();
        }
    }
}
```

**注意事项**

+ 读锁不支持条件变量

+ 重入时升级不支持：**即持有读锁的情况下去获取写锁，会导致获取写锁永久等待**

+ 重入时降级支持：即持有写锁的情况下去获取读锁

  ```java
  class CachedData {
      Object data;
      volatile boolean cacheValid;
      final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
      final ReentrantReadWriteLock.ReadLock r = rwl.readLock();
      final ReentrantReadWriteLock.WriteLock w = rwl.writeLock();
      
      void processCachedData() {
          r.lock();
          if (!cacheValid) {
              r.unlock();
              w.lock();
              try {
                  if (!cacheValid) {
                      data = ...;
                      cacheValid = true;
                  }
                  r.lock();
              } finally {
                  w.unlock();
              }
          }
          
          try {
              use(data);
          } finally {
              r.unlock();
          }
      }
  }
  ```

### 读写锁原理

读写锁用的是同一个 Sync 同步器，因此等待队列、state 等也是同一个

**t1  -->  w.lock   t2  -->  r.lock**

1. t1 成功上锁，流程与 ReentrantLock 加锁相比没有特别之处，不同的是写锁状态占了 state 的低16位，而读锁使用的是 state 的高16位

   ![image-20240929195621270](https://s2.loli.net/2024/09/29/y75iV9MSd8xYh6U.png)

   ```java
   protected final boolean tryAcquire(int acquires) {
       /*
        * Walkthrough:
        * 1. If read count nonzero or write count nonzero
        *    and owner is a different thread, fail.
        * 2. If count would saturate, fail. (This can only
        *    happen if count is already nonzero.)
        * 3. Otherwise, this thread is eligible for lock if
        *    it is either a reentrant acquire or
        *    queue policy allows it. If so, update state
        *    and set owner.
        */
       Thread current = Thread.currentThread();
       int c = getState();
       int w = exclusiveCount(c);
       if (c != 0) {
           // (Note: if c != 0 and w == 0 then shared count != 0)
           if (w == 0 || current != getExclusiveOwnerThread())
               return false;
           if (w + exclusiveCount(acquires) > MAX_COUNT)
               throw new Error("Maximum lock count exceeded");
           // Reentrant acquire
           setState(c + acquires);
           return true;
       }
       if (writerShouldBlock() ||
           !compareAndSetState(c, c + acquires))
           return false;
       setExclusiveOwnerThread(current);
       return true;
   }
   ```

2. t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么返回 -1 表示失败

   ```java
    public final void acquireShared(int arg) {
       if (tryAcquireShared(arg) < 0)
           doAcquireShared(arg);
   }
   ```

   > tryAcquireShared 返回值含义：
   >
   > + **-1** 表示失败
   > + **0** 表示成功，但后继节点不会继续唤醒
   > + **正数**表示成功，而且数值是还有几个后继节点需要唤醒，**读写锁返回 1**

   ![image-20240929195925732](https://s2.loli.net/2024/09/29/eWkJmUQ7uGhd3ia.png)

   ```java
   protected final int tryAcquireShared(int unused) {
       /*
        * Walkthrough:
        * 1. If write lock held by another thread, fail.
        * 2. Otherwise, this thread is eligible for
        *    lock wrt state, so ask if it should block
        *    because of queue policy. If not, try
        *    to grant by CASing state and updating count.
        *    Note that step does not check for reentrant
        *    acquires, which is postponed to full version
        *    to avoid having to check hold count in
        *    the more typical non-reentrant case.
        * 3. If step 2 fails either because thread
        *    apparently not eligible or CAS fails or count
        *    saturated, chain to version with full retry loop.
        */
       Thread current = Thread.currentThread();
       int c = getState();
       if (exclusiveCount(c) != 0 &&
           getExclusiveOwnerThread() != current)
           return -1;
       int r = sharedCount(c);
       if (!readerShouldBlock() &&
           r < MAX_COUNT &&
           compareAndSetState(c, c + SHARED_UNIT)) {
           if (r == 0) {
               firstReader = current;
               firstReaderHoldCount = 1;
           } else if (firstReader == current) {
               firstReaderHoldCount++;
           } else {
               HoldCounter rh = cachedHoldCounter;
               if (rh == null || rh.tid != getThreadId(current))
                   cachedHoldCounter = rh = readHolds.get();
               else if (rh.count == 0)
                   readHolds.set(rh);
               rh.count++;
           }
           return 1;
       }
       return fullTryAcquireShared(current);
   }
   ```

3. 上面一步因为写锁占据，所以进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态

   ```java
   private void doAcquireShared(int arg) {
       final Node node = addWaiter(Node.SHARED);
       boolean failed = true;
       try {
           boolean interrupted = false;
           for (;;) {
               final Node p = node.predecessor();
               if (p == head) {
                   int r = tryAcquireShared(arg);
                   if (r >= 0) {
                       setHeadAndPropagate(node, r);
                       p.next = null; // help GC
                       if (interrupted)
                           selfInterrupt();
                       failed = false;
                       return;
                   }
               }
               if (shouldParkAfterFailedAcquire(p, node) &&
                   parkAndCheckInterrupt())
                   interrupted = true;
           }
       } finally {
           if (failed)
               cancelAcquire(node);
       }
   }
   ```

   ![image-20240929200832623](https://s2.loli.net/2024/09/29/c8ZxL9J5G3thdYe.png)

4. t2 会再看看自己的节点是不是第一个关联线程的节点，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁

5. 如果没有成功，在 doAcquireShared 内 for 循环一次，把前驱节点的 waitStatus 改为 -1，再 for 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 **park**

   ![image-20240929201304593](https://s2.loli.net/2024/09/29/nJMaZNbGYRCcq8k.png)

**t3 r.lock, t4 w.lock**

这种情况下，这期间 t1 仍然持有锁，就变成下图：

**注意：**写锁的状态是 EXCULSIVE 独占状态（图中 Ex)

![image-20240929201432513](https://s2.loli.net/2024/09/29/JXCQyal4I2rnTfH.png)

**t1 w.unlock**

这时会走 sync.release(1) 流程，调用 sync.release(1) 成功

![image-20240929201640548](https://s2.loli.net/2024/09/29/HzXsilYOKomcShL.png)

接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行

这时再来一次 for 循环执行 tryAcquireShared 成功则让读锁计数加一

![image-20240929202259693](https://s2.loli.net/2024/09/29/5tHG2g4wcyolZPW.png)

这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点

![image-20240929202429591](https://s2.loli.net/2024/09/29/S3xFr15ObwREVKs.png)

在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并且唤醒这下一个节点，此时 t3 也恢复运行

![image-20240929202725781](https://s2.loli.net/2024/09/29/FDuLjlPhXqs7atW.png)

这回再来一次执行 tryAcquireShared 成功则让读锁计数加一

![image-20240929202957103](https://s2.loli.net/2024/09/29/OMfNY1hkR2EmowU.png)

这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在的节点置为头节点

![image-20240929203142223](https://s2.loli.net/2024/09/29/a2cvw51WsyYhGnI.png)

**t2 r.unlock  t3 r.unlock**

t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为 0

![image-20240929203417897](https://s2.loli.net/2024/09/29/LGs4PNzaDhgr8iY.png)

t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为0，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点也就是 t4

<img src="https://s2.loli.net/2024/09/29/snB4W8eO79JVFmd.png" alt="image-20240929203805260"  />

之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for 循环，这次没有竞争，tryAcquire(1) 成功，修改头节点，结束流程

### StampedLock

自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合**戳**使用

 加解读锁

```java
long stamp = lock.readLock();
lock.unlockRead(stamp);
```

加解写锁

```java
long stamp = lock.writeLock();
lock.unlockWrite(stamp);
```

乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一个**戳校验**，如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全性

```java
long stamp = lock.tryOptimisticRead();
// 验证戳
if (!lock.validate(stamp)) {
    // 锁升级
}
```

示例代码：

```java
public class TestStampedLock {
    public static void main(String[] args) throws InterruptedException {
        DataContainerStamped dataContainer = new DataContainerStamped(1);
        new Thread(() -> {
            try {
                dataContainer.read(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }).start();
        Thread.sleep(400);
        new Thread(() -> {
            try {
                dataContainer.write(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }).start();
//        new Thread(() -> {
//            try {
//                dataContainer.read(0);
//            } catch (InterruptedException e) {
//                throw new RuntimeException(e);
//            }
//        }).start();
    }
}

@Slf4j
class DataContainerStamped {
    private int data;
    private final StampedLock lock = new StampedLock();

    public DataContainerStamped(int data) {
        this.data = data;
    }
    public int read(int readTime) throws InterruptedException {
        long stamp = lock.tryOptimisticRead();
        log.debug("optimistic read locking... {}", stamp);
        Thread.sleep(readTime);
        if (lock.validate(stamp)) {
            log.debug("read finish.. {}", stamp);
            return data;
        }
        log.debug("update to read lock");
        try {
            stamp = lock.readLock();
            log.debug("read lock {}", stamp);
            Thread.sleep(readTime);
            log.debug("read finish... {}", stamp);
            return data;
        } finally {
            log.debug("read unlock {}", stamp);
            lock.unlockRead(stamp);
        }

    }

    public void write(int newData) throws InterruptedException {
        long stamp = lock.writeLock();
        log.debug("write lock {}", stamp);
        try {
            Thread.sleep(2000);
            this.data = newData;
        } finally {
            log.debug("write unlock {}", stamp);
            lock.unlockWrite(stamp);
        }
    }
}
```

**特点：**

+ StampedLock 不支持条件变量
+ StampedLock 不支持可重入



### Semaphore 信号量

用来限制能同时访问共享资源的线程上限

```java
@Slf4j
public class TestSemaphore {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                log.info("running...");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }finally {
                    semaphore.release();
                }
                log.info("end...");
            }, "t" + i).start();
        }
    }
}
```

**应用**

+ 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放，**仅是限制线程数，而不是限制资源数（例如连接数）**

+ 用 Semaphore 实现简单连接池，对比**享元模式**下的实现（wait notify)，性能和可读性显然更好

  ```java
  @Slf4j
  class Pool2 {
      private final int poolSize;
  
      private Connection[] connections;
  
      // 3. 连接状态数组 0 表示空闲 1 表示繁忙
      private AtomicIntegerArray states;
  
      private Semaphore semaphore;
  
      public Pool2(int size) {
          this.poolSize = size;
          this.semaphore = new Semaphore(size);
          this.connections = new Connection[poolSize];
          this.states = new AtomicIntegerArray(new int[poolSize]);
          for (int i = 0; i < poolSize; i++) {
              connections[i] = new MockConnection("连接" + (i + 1));
          }
      }
  
      public Connection borrow() {
          try {
              semaphore.acquire();
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
          for (int i = 0; i < poolSize; i++) {
              if (states.get(i) == 0) {
                  if (states.compareAndSet(i, 0, 1)) {
                      log.debug("borrow {}", connections[i]);
                      return connections[i];
                  }
              }
          }
          return null;
      }
  
      public void free(Connection conn) {
          for (int i = 0; i < poolSize; i++) {
              if (connections[i] == conn) {
                  states.set(i, 0);
                  log.debug("free {}", conn);
                  semaphore.release();
                  break;
              }
          }
  
      }
  }
  ```

### Semaphore 原理

加锁解锁原理

```java
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}
```

假设一开始 permits(state) 为 3，这时 5 个线程来获取资源

![image-20240930181332919](https://s2.loli.net/2024/09/30/MuCHknm93xGBLPR.png)

假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞

```java
public void acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
```

![image-20240930181840367](https://s2.loli.net/2024/09/30/z7VMaypdKh2iQZ8.png)

这时 Thread-4 调用 release() 方法

```java
public void release() {
    sync.releaseShared(1);
}

public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}

protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next < current) // overflow
            throw new Error("Maximum permit count exceeded");
        if (compareAndSetState(current, next))
            return true;
    }
}
```

![image-20240930182526072](https://s2.loli.net/2024/09/30/AqU48GXZskopenM.png)

接下来 Thread-0 竞争成功，permits 再次设置为0，设置自己为 head 节点，unpark 接下来的 Thread-3 节点，但由于 state 是 0 ，因此 Thread-3 在尝试不成功之后再次进入 park 状态

![image-20240930182706082](https://s2.loli.net/2024/09/30/tfreb4BE7U892u5.png)

### CountdownLatch

用于进行线程间同步协作，等待所有线程完成倒计时

其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一

```java
@Slf4j
public class TestCountdownLatch {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);

        ExecutorService executorService = Executors.newFixedThreadPool(4);
        executorService.submit(() -> {
            log.info("begin");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            latch.countDown();
            log.debug("end");
        });

        executorService.submit(() -> {
            log.info("begin");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            latch.countDown();
            log.debug("end");
        });
        executorService.submit(() -> {
            log.info("begin");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            latch.countDown();
            log.debug("end");
        });
        executorService.submit(() -> {
            log.debug("waiting");
            try {
                latch.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            log.debug("wait end");
        });
    }
}
```

### CyclicBarrier

用来进行线程协作，等待线程满足某个计数。构造时设置**计数个数**，每个线程执行到某个需要**同步**的时刻调用 await() 方法进行等待，当等待的线程数满足**计数个数**时，继续执行，相比 CountdownLatch，可以循环使用

```
@Slf4j
public class TestCountdownLatch {

    public static void main(String[] args) throws InterruptedException {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(2, () -> {
            log.debug("task1 task2 finish");
        });

        ExecutorService executorService = Executors.newFixedThreadPool(2);
        for (int i = 0; i < 3; i++) {
            executorService.submit(() -> {
                log.info("task 1 begin");
                try {
                    Thread.sleep(1000);
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    throw new RuntimeException(e);
                }
                log.debug("end");
            });
            executorService.submit(() -> {
                log.info("task2 begin");
                try {
                    Thread.sleep(3000);
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    throw new RuntimeException(e);
                }
                log.debug("end");
            });
        }
    }
}
```

这里如果想要 task1 task2 执行完之后执行`log.debug("task1 task2 finish");`，必须要 CyclicBarrier 的 parties 与 线程池线程数相等

### 线程安全集合类（部分）

#### ConcurrentHashMap

JDK 7 直接使用线程不安全的 HashMap 在多线程情况下会出现**死链现象**



#### ConcurrentHashMap JDK 8 分析

**构造器分析**

```java
public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (initialCapacity < concurrencyLevel)   // Use at least as many bins
        initialCapacity = concurrencyLevel;   // as estimated threads
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    int cap = (size >= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    this.sizeCtl = cap;
}
```

`tableSizeFor`仍然是保证计算的大小是 2^n



**get流程** 全程没有加锁 性能高

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // spread 保证返回值为正数
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // 如果头节点已经是要查找的key
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法查找
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        // 正常遍历链表，用 equals 比较
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```



**put 流程**

以下数组简称`table`，链表简称`bin`

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    // 其中 spread 方法会综合高低位，具有更好的 hash 性
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        // f 是链表头节点
        // fh 是链表头节点的 hash
        // i 是链表在 table 中的下标
        Node<K,V> f; int n, i, fh;
        // 懒惰初始化 要创建 table
        if (tab == null || (n = tab.length) == 0)
            // 初始化 table 使用了 cas，无需 synchronized 创建成功，进入下一轮循环
            tab = initTable();
        // 要创建链表头节点
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // 添加链表头使用了 CAS ，无需 synchronized
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        // 帮忙扩容
        else if ((fh = f.hash) == MOVED)
            // 帮忙之后 进入下一轮循环
            tab = helpTransfer(tab, f);
        else {
            // 这个分支表示出现冲突
            V oldVal = null;
            // 锁住链表头节点
            synchronized (f) {
                // 再次确认链表头节点没有被移动
                if (tabAt(tab, i) == f) {
                    // 链表
                    if (fh >= 0) {
                        binCount = 1;
                        // 遍历链表
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // 找到相同的 key
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            // 已经是最后的节点了，新增 Node，追加至链表尾
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // 红黑树
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        // putTreeVal 会看 key 是否已经在树中，是则返回对应的 TreeNode
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
                // 释放链表头节点的锁
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    // 如果链表长度 >= 树化阈值（8），进行链表转为红黑树
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    // 增加 size 计数
    addCount(1L, binCount);
    return null;
}
```

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) < 0)
            Thread.yield(); // lost initialization race; just spin
        // 尝试将 sizeCtl 设置为 -1 （表示初始化 table）
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            // 获得锁，创建 table，这时其他线程会在 while() 循环中 yield 直到 table 创建
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

```java
// check 是之前 binCount 的个数
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if (
        // 已经有了 counterCells，向 cell 累加
        (as = counterCells) != null ||
        // 还没有，向 baseCount 累加
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (
            // 还没有 counterCells
            as == null ||  (m = as.length - 1) < 0 ||
            // 还没有 Cell
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            // cell cas 增加计数失败 
            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // 创建累加单元数组和 cell, 累加重试
            fullAddCount(x, uncontended);
            return;
        }
        if (check <= 1)
            return;
        // 获取元素个数
        s = sumCount();
    }
    if (check >= 0) {
        Node<K,V>[] tab, nt; int n, sc;
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n) << RESIZE_STAMP_SHIFT;
            if (sc < 0) {
                if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||
                    (nt = nextTable) == null || transferIndex <= 0)
                    break;
                // newtable 已经创建了，帮忙扩容
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            // 需要扩容，这时 newtable 未创建
            else if (U.compareAndSwapInt(this, SIZECTL, sc, rs + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
```



**size 计算流程**

size 计算实际发生在 put，remove 改变集合元素的操作之中

+ 没有竞争发生，向 baseCount 累加计数
+ 有竞争发生，新建 counterCells，向其中一个 Cell 累加计数
  + counterCells 初始有两个 Cell
  + 如果计数竞争比较激烈，会创建新的 Cell 来累加计数

> 计数可能存在误差



**扩容流程 transfer**

***略***



#### ConcurrentHashMap JDK 7 分析

它维护了一个 segment 数组，每个 segment 对应一把锁

+ 优点：如果多个线程访问不同的 segment，实际是没有冲突的，提高并发
+ 缺点：segments 数组默认大小是 16，这个容量初始化后无法改变，并且不是懒惰初始化

**构造器分析**

```java
public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    // segmentShift 默认是 32 - 4 = 28
    this.segmentShift = 32 - sshift;
    // segmentMask 默认是 15
    this.segmentMask = ssize - 1;
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap < c)
        cap <<= 1;
    // 创建 segments and segments[0]
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
```

<img src="https://s2.loli.net/2024/09/30/IuKHrZ3RNDot87e.png" alt="image-20240930212019445" style="zoom:50%;" />

其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment

先将 hash 右移 segmentShift 位，接着再与 segmentMask 做**与操作**

**put 流程**

```java
public V put(K key, V value) {
    Segment<K,V> s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // 计算 segment 下标
    int j = (hash >>> segmentShift) & segmentMask;
    // 获得 segment对象，判断是否为 null, 是则创建 segment
    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
        
        // ensureSegment 里用 cas 方式保证该 segment 安全性
        s = ensureSegment(j);
    // 进入 segment 的 put 流程
    return s.put(key, hash, value, false);
}
```

```java
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 尝试加锁
    HashEntry<K,V> node = tryLock() ? null :
    	// 如果不成功进入 scanAndLockForPut
    	// 如果是多核 CPU 最多 tryLock 64次，进入 lock 流程
    	// 在尝试期间，还可以顺便看看该节点在链表中有没有，如果没有顺便创建出来
        scanAndLockForPut(key, hash, value);
    
    // 执行到这里 成功加锁
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        int index = (tab.length - 1) & hash;
        HashEntry<K,V> first = entryAt(tab, index);
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                // 更新
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // 新增
                // 1) 之前等待锁时，node 已经被创建，next 指向链表头
                if (node != null)
                    node.setNext(first);
                else
                    // 2) 创建新节点
                    node = new HashEntry<K,V>(hash, key, value, first);
                int c = count + 1;
                // 3) 扩容
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // 将 node 作为链表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
```



**rehash流程**

因为在 put 中，已经加过锁，不用考虑安全问题

```java
private void rehash(HashEntry<K,V> node) {
    HashEntry<K,V>[] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity << 1;
    threshold = (int)(newCapacity * loadFactor);
    HashEntry<K,V>[] newTable =
        (HashEntry<K,V>[]) new HashEntry[newCapacity];
    int sizeMask = newCapacity - 1;
    for (int i = 0; i < oldCapacity ; i++) {
        HashEntry<K,V> e = oldTable[i];
        if (e != null) {
            HashEntry<K,V> next = e.next;
            int idx = e.hash & sizeMask;
            if (next == null)   //  只有一个 直接搬过去
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                HashEntry<K,V> lastRun = e;
                int lastIdx = idx;
                // 过一遍链表，尽可能把 rehash 后 idx 不变的节点重用
                for (HashEntry<K,V> last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash & sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
              	// 直接搬过去
                newTable[lastIdx] = lastRun;
                // 剩余节点需要新建
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
            }
        }
    }
    // 扩容完成后 才会加入新的节点
    int nodeIndex = node.hash & sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    // 替换
    table = newTable;
}
```

**get 流程**

get 并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表中取，get 后发生就从新表取

```java
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    // u 为 segment 对象在数组中的偏移量
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    // s 就是 segment
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```



**size 计算流程**

+ 计算元素个数前，先不加锁计算两次，如果前后两次结果一样，认为个数正确返回
+ 如果不一样进行重试，重试超过 3 次，将所有 segment 锁住，重新计算个数返回

```java
public int size() {
    final Segment<K,V>[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            if (retries++ == RETRIES_BEFORE_LOCK) {
                // 超过重试次数，对所有 segment 加锁
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
```



#### LinkedBlockingQueue

内部节点结构

```java
static class Node<E> {
    E item;

    /**
     * One of:
     * - the real successor Node
     * - this Node, meaning the successor is head.next
     * - null, meaning there is no successor (this is the last node)
     */
    Node<E> next;

    Node(E x) { item = x; }
}
```



**加锁分析**

用了两把锁和 dummy 节点

+ 如果用一把锁，同一时刻，最多只允许一个线程执行
+ 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与消费者）执行
  + 消费者与消费者**仍然串行**
  + 生产者与生产者**仍然串行**

线程安全分析

+ 节点总数大于2，putLock 保证 last 节点的线程安全，takeLock 保证 head 节点的线程安全，无竞争
+ 节点总数等于2（一个 dummy，一个正常节点），仍然是锁两个对象，不会竞争
+ 节点总数等于1（一个 dummy），这时会被 notEmpty 条件阻塞

**put 流程**

```java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    int c = -1;
    Node<E> node = new Node(e);
    final ReentrantLock putLock = this.putLock;
    // count 维护元素个数
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        // 满了等待
        while (count.get() == capacity) {
            // 等待 notFull
            notFull.await();
        }
        // 有空位，入队且计数+1
        enqueue(node);
        c = count.getAndIncrement();
        // 除了自己 put 之外，还有空位，叫醒别的 put 线程
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    // 如果队列中有一个元素，叫醒 take 线程
    if (c == 0)
        signalNotEmpty();
}
```

**take 流程**

```java 
 public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        while (count.get() == 0) {
            notEmpty.await();
        }
        x = dequeue();
        c = count.getAndDecrement();
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    // 如果队列中只有一个空位，叫醒 put 线程
    // 如果有多个线程进行出队，第一个线程满足 c == capacity 
    if (c == capacity)
        // 减少竞争
        signalNotFull();
    return x;
}
```



LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较

+ Linked 支持有界，Array 强制有界
+ Linked 实现是链表，Array 实现是数组
+ Linked 是懒惰的，Array 需要提前初始化 Node 数组
+ Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的
+ Linked 两把锁，性能更好，Array 一把锁



#### ConcurrentLinkedQueue

ConcurrentLinkedQueue 设计与 LinkedBlockingQueue 非常像

+ 两把锁，同一时刻运行一个消费者和一个生产者同时执行
+ 也引入 dummy 节点
+ 但是这里的**锁**使用了 CAS 实现保证安全



#### CopyOnWriteArrayList

底层实现采用了**写入时拷贝**思想，CRUD 操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其他线程的**并发读**，**读写分离**

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 获取旧数组
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝新的数组
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 添加新元素
        newElements[len] = e;
        // 替换旧数组
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

**读操作并没有加锁**

适合【**读多写少**】的场景

**get 弱一致性**

**迭代器 弱一致性**

