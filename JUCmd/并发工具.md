# 并发工具

## 自定义线程池

![image-20240927095534232](https://s2.loli.net/2024/09/27/2uBOaC7XfyIt6AW.png)

```java
@Slf4j
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1,
                1000, TimeUnit.MILLISECONDS,
                1,
                (queue, task) -> {
            // 永久等待
//            queue.put(task);
            // 超时等待
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            // 放弃
//            log.debug("give up the task {}", task);
            // 让调用者抛出异常
//                throw new RuntimeException("task execute failed " + task);
            // 让调用者自己执行任务
                task.run();
        });
        for (int i = 0; i < 5; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                log.debug("{}", j);
            });
        }
    }

}

@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}

@Slf4j
class ThreadPool {
    private BlockingQueue<Runnable> taskQueue;

    private HashSet<Worker> workers = new HashSet<>();

    private int coreSize;

    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy<Runnable> rejectPolicy;

    public void execute(Runnable task) {
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("add worker: {} {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
//            while (task != null || (task = taskQueue.take()) != null) {
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("running... {}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug("worker removed: {}", this);
                workers.remove(this);
            }
        }
    }
}
@Slf4j
class BlockingQueue<T> {
    // 任务队列
    private Deque<T> queue = new ArrayDeque<>();

    // 锁
    private ReentrantLock lock = new ReentrantLock();

    // 生产者条件变量
    private Condition fullWaitSet = lock.newCondition();

    // 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();

    // 容量
    private int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    // 带超时的阻塞获取
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 返回的是剩余时间
                    if (nanos <= 0) return null;
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 带超时时间阻塞添加
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    log.debug("wait to addLst taskQueue {}", task);
                    if (nanos <= 0) return false;

                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("addLast taskQueue {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否已满
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                log.debug("addLast taskQueue {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```



## ThreadPoolExecutor

### 线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

这些信息存储在一个原子变量 ctl 中，目的是将线程状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值

```java
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)));

private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                         int maximumPoolSize,
                         long keepAliveTime,
                         TimeUnit unit,
                         BlockingQueue<Runnable> workQueue,
                         ThreadFactory threadFactory,
                         RejectedExecutionHandler handler)
```

+ corePoolSize 核心线程数量（最多保留的线程数）
+ maximumPoolSize 最大线程数目
+ keepAliveTime 生存时间 - 针对救急线程
+ unit 时间单位 - 针对救急线程
+ workQueue 阻塞队列
+ threadFactory 线程工厂
+ handler 拒绝策略

线程池工作过程：

+ 一开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务
+ 当线程数量达到 corePoolSize 并且没有线程空闲，这时再加入任务，新加的任务会被加入 workQueue 队列排队，直到有空闲线程
+ 如果队列选择了有界队列，那么任务超过队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急
+ 如果线程达到 maximumPoolSize 仍然有新任务时这时会执行拒绝策略。拒绝策略 JDK 提供了4种，其他框架也提供了别的实现
  + AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
  + CallerRunPolicy 让调用者执行任务
  + DiscardPolicy 放弃本次任务
  + DiscardOldestPolicy放弃队列中最早的任务，本任务取而代之
  + Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
  + Netty 的实现，是创建一个新线程来执行任务
  + ActiveMQ 的实现，带超时等待（60s）尝试放入队列，
  + PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
+ 当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制

### newFixedThreadPool

特点：

+ 核心线程数 == 最大线程数
+ 阻塞队列是无界的，可以放置任意个数的任务

> 适用于任务数量固定，相对耗时的任务

### newCachedThreadPool

特点：

+ 核心线程数是0，最大线程数是 Integer.MAX_VALUE ，救急线程的空闲生存时间是 60s，意味着
  + 全部都是救急线程（60s后回收）
  + 救急线程可以无限创建
+ 队列采用了 SynchronousQueue 实现特点是：他没有容量，没有线程来取是放不进去的

> 适合任务数比较密集，但每个任务执行时间比较短的情况

### newSingleThreadExecutor

使用场景：

+ 希望多个任务排队执行。线程数固定为 1 ，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会释放

区别：

+ 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作
+ newSingleThreadExecutor的线程数始终为 1，不能修改，原理是通过装饰器模式对 ThreadPoolExecutor 进行包装，对外关闭了暴露的修改方法
+ 如果使用newFixedThreadPool(1) 创建，对外暴露的是 ThreadPoolExecutor 对象，可以强转之后修改线程池大小



### 提交任务

**execute 方法**

提交任务，没有返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);
pool.execute(() -> {
    log.info("执行任务");
});
```

**submit(Callable task) 方法 **

提交任务，并用 future 接收返回结果

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<String> future = pool.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                log.info("执行任务");
                return "返回结果";
            }
        });
        String res = future.get();
        log.info(res);
```

**invokeAll 方法**

提交集合中所有任务，可以带超时时间

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

List<Future<Integer>> futures = pool.invokeAll(Arrays.asList(
        () -> {
            log.info("执行任务1");
            Thread.sleep(100);
            return 1;
        },
        () -> {
            log.info("执行任务2");
            Thread.sleep(5000);
            return 2;
        }
));

futures.forEach( f -> {
    try {
        log.debug("返回值：{}", f.get());
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
});
```

**invokeAny 方法**

提交集合中所有任务，哪个任务先执行成功，返回此任务执行结果，其他任务取消

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

Integer res = pool.invokeAny(Arrays.asList(
        () -> {
            Thread.sleep(100);
            log.info("执行任务1");
            return 1;
        },
        () -> {
            Thread.sleep(300);
            log.info("执行任务2");
            return 2;
        }
));
log.debug("res: {}", res);
```

### 关闭线程池

shutdown方法

线程池状态变为**SHUTDOWN**，不会接收新任务，但已提交任务会执行完，此方法不会阻塞调用线程的执行



shutdownNow方法

线程池状态变为**STOP**，不会接收新任务，会将队列中的任务返回，并用 interrupt 的方式中断正在执行的任务



### 工作线程的饥饿现象

如果一个线程既要负责A的执行又要负责B的执行，并且A与B之前存在关系，那么可能导致**饥饿**现象

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }
}

// 输出：
2024-09-27 15:41:37 [pool-1-thread-2] INFO - 点餐
2024-09-27 15:41:37 [pool-1-thread-1] INFO - 点餐
```

**解决方式**

创建不同的线程池分别负责不同类型的任务，可以避免**饥饿现象**

```java
@Slf4j
public class TestSubmit {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(1);
        ExecutorService pool2 = Executors.newFixedThreadPool(1);

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        pool.execute(() -> {
            log.info("点餐");
            Future<String> future = pool2.submit(() -> {
                log.info("开始做菜");
                return "菜";
            });
            try {
                log.info("上菜：{}", future.get());
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });

        Thread.sleep(1000);
        pool.shutdown();
        pool2.shutdown();
    }
}

// 输出：
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 点餐
2024-09-27 15:45:05 [pool-2-thread-1] INFO - 开始做菜
2024-09-27 15:45:05 [pool-1-thread-1] INFO - 上菜：菜

进程已结束，退出代码为 0
```



### 创建多少线程池合适？

对于**CPU密集型**运算

> 通常采用**CPU 核数 + 1**能够实现最优的 CPU 利用率，**+1**是保证当线程由于页缺失故障或其他原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不浪费

对于 **I/O 密集型**运算

> 经验公式：`线程数 = 核数 * 期望 CPU 利用率 * 总时间（CPU计算时间 + 等待时间）/ CPU 计算时间`



## 任务调度线程池

**schedule方法**

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
    pool.schedule(() -> {
        log.info("task1");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
    pool.schedule(() -> {
        log.info("task2");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }, 1, TimeUnit.SECONDS);
}
```

**scheduleWithFixedDelay方法**

**scheduleAtFixedRate方法**



## 线程池的异常处理

1. 直接在任务内部捕捉异常
2. 使用`Callable<T>`来执行任务并带有返回值，调用`Future.get()`会捕捉异常



## 任务调度线程池应用 - 定时任务

```java
public class TestSubmit {

    // 如何让每周四 18：00：00定时执行任务
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);

        if (now.isAfter(time)) time.plusWeeks(1);
        System.out.println(time);


        long initDelay = Duration.between(now, time).toMillis();
        System.out.println(initDelay);
        long period = 2000;

        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
        pool.scheduleAtFixedRate(() -> {
            log.info("yes");
        }, initDelay, period, TimeUnit.MILLISECONDS);
    }
}
```



## Tomcat 线程池

Tomcat 在哪里用到了线程池呢？

![image-20240927164100537](https://s2.loli.net/2024/09/27/69ZtIc7GfRnHe18.png)

+ LimitLatch 用来限流，可以控制最大连接数
+ Acceptor 只负责**接收新的 socket 连接**
+ Poller 只负责监听 socket channel 是否有**可读的 I/O 事件**
+ 一旦可读，封装到一个任务对象**socketProcessor**，提交给 Executor 线程池处理
+ Executor 线程池中的工作线程最终负责**处理请求**

Tomcat线程池**拓展了**ThreadPoolExecutor，行为稍有不同

+ 如果总线程达到 maximumPoolSize
  + 这时不会立刻抛异常
  + 而是再次尝试将任务放入队列，如果还失败才抛异常

Tomcat 对于救急线程的创建流程也进行了改变

![image-20240927165548316](https://s2.loli.net/2024/09/27/RvcxND6tlHYEgq8.png)



## Fork/Join

JDK 1.7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算

Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提高了运算效率

默认会创建与 CPU 核心数相同的线程池

```java
public class TestForkJoin {
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool(10);
        for (int i = 0; i < 10; i++) {
            long start = System.currentTimeMillis();
            System.out.println(pool.invoke(new MyTask(1, 1000000000)));
            long end = System.currentTimeMillis();
            System.out.println(end - start);
        }
    }
}

@Slf4j
class MyTask extends RecursiveTask<Integer> {

    private int begin;
    private int end;

    public MyTask(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (begin == end) {
            return begin;
        }
        if (end == begin + 1) {
            return begin + end;
        }

        int mid = (begin + end) >> 1;
        MyTask t1 = new MyTask(begin, mid);
        MyTask t2 = new MyTask(mid + 1, end);
        t1.fork();
        t2.fork();
//        log.debug("fork() {} + {} = ?", t1, t2);
        int result = t1.join() + t2.join();
//        log.debug("join() {} + {} = {}", t1, t2, result);
        return result;
    }
}
```

