# 运行时数据区

JVM在运行Java程序时管理的内存区域，称之为**运行时数据区**

分为两大类：

+ 线程不共享

  > 每当你创建一个线程之后，每个线程里面都会有一份程序计数器、Java虚拟机栈、本地方法栈

+ 线程共享

  > 方法区和堆是线程共享的区域

![image-20240919095248445](https://s2.loli.net/2024/09/19/zLjKp2vTrnYHOh1.png)



## 程序计数器

也叫**PC寄存器**，每个线程会通过程序计数器记录当前要执行的字节码指令的地址。

在加载阶段，虚拟机将字节码文件中的指令读取到内存中之后，会将原文件中的偏移量转换成内存地址，每一条字节码指令都会拥有一个内存地址

程序计数器可以控制程序指令的执行，实现**分支、跳转、异常等逻辑**

在**多线程**执行的情况下，JVM需要通过程序计数器记录CPU切换前解释执行到哪一句指令并继续解释执行



## Java虚拟机栈

随着线程的创建而创建，而回收会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程拥有自己的Java虚拟机栈

## 栈帧的组成

+ 局部变量表

  在运行过程中存放所有的局部变量

  ![image-20240919101354339](https://s2.loli.net/2024/09/19/7vBeojNPRHDSw9c.png)

  栈帧中的局部变量表是一个数组，每一个位置称之为**槽（slot）**，`long`和`double`类型占用2个槽，其他类型占用一个槽

  ![image-20240919101422100](https://s2.loli.net/2024/09/19/DWpamSeyM2B5lVI.png)

  实例方法中的序号为0的位置存放的是`this`，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址

  方法的参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致

  ![image-20240919101646489](https://s2.loli.net/2024/09/19/ARiDWQe59x2yq7j.png)

  **为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽可以再次被使用**

  ![image-20240919101931062](https://s2.loli.net/2024/09/19/mqlXGzrOZQ1p5Lt.png)

  > **图中源代码只会占用6个**

+ 操作数栈

  操作数栈是虚拟机在执行指令过程中用来存放**中间数据**的一块区域

  在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小

  

+ 帧数据

  主要包括动态链接、方法出口、异常表的引用

  

  当前类的字节码指令引用了其他类的属性或方法时，需要将符号引用转换成对应的运行时常量池中的内存地址。**动态链接**就保存了编号到运行时常量池的内存地址的映射关系

  ![image-20240919102744181](https://s2.loli.net/2024/09/19/53kBqJyHeTLuhZK.png)

  

  **方法出口**指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。

  ![image-20240919103000211](https://s2.loli.net/2024/09/19/kQg7vJNeazALEoI.png)

  ![image-20240919103022331](https://s2.loli.net/2024/09/19/CQ68ARLJ35IvSlu.png)

  

  **异常表**存放的是的代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置

  ![image-20240919103335158](https://s2.loli.net/2024/09/19/mrotpGWalyOSVMR.png)

**要修改Java虚拟机栈的大小，可以使用JVM参数：`-Xss1048576`，`-Xss1024K`，`-Xss1m`，`-Xss1g`**

**即便可以手动设置，但是JVM对栈大小有最大最小值的要求**



## 本地方法栈

本地方法栈存放的是`native`本地方法的栈帧

在Hotspot虚拟机中，**Java虚拟机栈和本地方法栈实现上使用了同一个栈空间**。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来



## 堆

创建出来的对象都存在于堆上

栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享

堆空间有三个需要关注的值，`used`，`total`，`max`

`used`指的是当前已使用的堆内存，`total`是Java虚拟机已经分配的可用堆内存，`max`是Java虚拟机可以分配的最大堆内存

虚拟机参数`-Xms大小`设置初始`total`值，`-Xmx大小`设置初始`max`值



## 方法区

方法区是存放基础信息的位置，线程共享，主要包含三部分内容：

1. 类的元信息

   保存了所有类的基本信息，一般称之为`InstanceKlass`对象

2. 运行时常量池

   保存了字节码文件中的常量池内容

3. 字符串常量池

   保存了字符串常量

方法区是一个虚拟概念，每款JVM上的实现各不相同。Hotspot设计如下：

+ **JDK7及之前版本**将方法区存放在**堆的永久代空间**，可以通过JVM参数`-XX:MaxPermSize=值`来控制
+ **JDK8及之后版本**将方法区存放在**元空间**中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受上限，可以一直分配。可以使用`-XX:MaxMetaspaceSize=值`将元空间最大空间进行限制



## 直接内存

直接内存并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域

在JDK1.4中引入NIO机制，使用了直接内存，主要为了解决以下问题：

+ Java堆中的对象如果不再使用需要回收，回收时会影响对象的创建和使用
+ IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。现在直接放入直接内存中即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。

要创建直接内存上的数据，可以使用`ByteBuffer`

```java
ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);
```

可以手动设置直接内存的上限：`-XX:MaxDirectMemorySize=大小`

**Q: 不同JDK版本之间运行时数据区域的区别是什么？**

JDK 6:

![image-20240919124941520](https://s2.loli.net/2024/09/19/nJcip1LgxDsm8hV.png)

JDK 7:

![image-20240919125010597](https://s2.loli.net/2024/09/19/JdQFythCDYj6N2c.png)

JDK 8:

![image-20240919130232396.png](https://s2.loli.net/2024/09/19/TyBuIzbEP2LSdKY.png)